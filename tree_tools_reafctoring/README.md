Задание - прочитать badcode, сказать что это, отрефакторить.

Итак, я поколупала его сама:)

У нас три файла badcode, goodcode и pytoniccode.

С badcode все понятно - алгоритм единым куском. 

goodcode максимально близок к первому, но не завит от операционной системы и читаем. Оставлены дубликаты кода чтобы можно было сразу понять что где и изменить.

С pytoniccode все интереснее. Он отделяет абстракцией интерфейс командной строки, разделяет вычисление дерева и его печать, появляются классы и аннотации, чтобы выпендрится я еще файлики подсветила (для наглядности надо бы еще по модулям раскидать, написать комментариев к каждому методу, тесты написать, ридми, поставить тег версии в гите, автоматизировать тесты чтобы они запускались при коммите но я решила что кажется пора остановиться).

Использует контекстный менеджер, регулярные выражения, датаклассы. Очень гибкий. Красивенький.

Никогда так не делайте.

Во первых код теряет свойство "поправит любой админ / джун". Во вторых он не приобретает ничего необходимого на данный момент. В третьих его жальчее выкинуть, что как по мне причина половины монструозных котдовых раковых опухолей в проекте.



Любое решение сложнее комбинации из пары методов должно быть обдумано и обосновано. Зачем я абстракции накрутила? Зачем мне структуры данных? Я делаю что то монументальное? Если да то думали ли над архитектурой, и что гораздо важнее, об использовании чего то готового?

Красивый, сложный, абстрактный код писать приятно. Но часто нахрен никому изначально не нужно до момента пока мы не определились с тем что делаем, и надо ли вообще в это вкладывать силы и писать универсальное решение, не будет ли проще изучить утилиту tree...



А еще на формальном ревью можно легко улететь в сторону третьего варианта:) Когда лидосеньор не думает о целесообразности правок а просит нанести красоты на автомате.